<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ProbeMind — CDR Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --header-h: 64px; --footer-h: 44px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", sans-serif; color: #eaeaea; background: #0b0f16; overflow: hidden; }
    #bg { position: fixed; inset: 0; z-index: 0; background: radial-gradient(1200px 800px at 50% 50%, #0e1624 0%, #0b0f16 60%, #070a0f 100%); }
    header, footer {
      position: fixed; left: 0; right: 0; z-index: 2;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    header { top: 0; height: var(--header-h); display: flex; align-items: center; padding: 0 16px; }
    footer { bottom: 0; height: var(--footer-h); display: flex; align-items: center; justify-content: space-between; padding: 0 16px; border-top: 1px solid rgba(255,255,255,0.08); border-bottom: none; }
    .brand { font-weight: 800; letter-spacing: 0.5px; font-size: 18px; margin-right: 16px; white-space: nowrap; }
    nav a { color: #eaeaea; text-decoration: none; margin: 0 10px; padding: 8px 12px; border-radius: 999px; }
    nav a:hover { background: rgba(255,255,255,0.08); }
    nav a.active { background: #14b8a6; color: #021012; }
    main { position: relative; z-index: 1; height: calc(100% - var(--header-h) - var(--footer-h)); margin-top: var(--header-h); margin-bottom: var(--footer-h); overflow: auto; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 28px 16px 40px; }
    .panel { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.09); border-radius: 20px; padding: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.06); }
    h1 { margin: 10px 0 18px; font-size: clamp(22px, 3.6vw, 34px); }
    input[type=file] { margin: 12px 0; }
    button {
      padding: 10px 14px; border-radius: 12px; background: #14b8a6; color: #041012; border: none; font-weight: 700; cursor: pointer;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    table { border-collapse: collapse; width: 100%; margin: 12px 0; background: rgba(0,0,0,0.25); }
    th, td { padding: 6px 10px; border: 1px solid rgba(255,255,255,0.08); font-size: 13px; text-align: left; }
    .small { font-size: 13px; color: #9db0c6; margin-top: 4px; }
    .summary-list { display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); gap:8px; margin-top: 12px; }
    .metric { background: rgba(255,255,255,0.02); padding:10px; border-radius:8px; }
    a { position: relative; z-index: 3; }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <header>
    <div class="brand">ProbeMind</div>
    <nav>
      <a href="index.html">Home Page</a>
      <a href="ifsc.html">IFSC Search</a>
      <a href="tower.html">Tower Search</a>
      <a class="active" href="cdr.html">CDR Analysis</a>
    </nav>
  </header>

  <main>
    <div class="wrap">
      <div class="panel">
        <h1>CDR Analysis</h1>
        <p class="small">Upload .csv / .xlsx / .xls / .xlsb file. Report will auto-generate in browser (no server needed).</p>

        <input id="file" type="file" accept=".csv,.xlsx,.xls,.xlsb" />
        <div>
          <button id="analyzeBtn">Analyze CDR</button>
          <button id="downloadBtn" disabled>Download Excel Report</button>
          <span id="status" class="small">No file selected.</span>
        </div>

        <div id="output"></div>
      </div>
    </div>
  </main>

  <footer>
    <div class="footer-left">© 2025 ProbeMind.in</div>
    <div class="footer-right">Developed by Omeshwar Vankar</div>
  </footer>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    /* === Particle Background Animation (same as ifsc.html) === */
    (function() {
      const canvas = document.getElementById('bg');
      const ctx = canvas.getContext('2d');
      let w,h,particles=[],mouse={x:null,y:null},maxDist=140;
      function resize(){ w=canvas.width=window.innerWidth; h=canvas.height=window.innerHeight;
        const targetCount=Math.min(160,Math.floor((w*h)/12000));
        if(particles.length<targetCount){while(particles.length<targetCount)particles.push(newParticle());}
        else{particles.length=targetCount;} }
      function newParticle(){return{x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.6,vy:(Math.random()-0.5)*0.6,r:1+Math.random()*2};}
      function step(){ctx.clearRect(0,0,w,h);
        for(let i=0;i<particles.length;i++){const p=particles[i];p.x+=p.vx;p.y+=p.vy;
          if(p.x<0||p.x>w)p.vx*=-1;if(p.y<0||p.y>h)p.vy*=-1;
          if(mouse.x!==null){const dx=mouse.x-p.x,dy=mouse.y-p.y,d2=dx*dx+dy*dy;if(d2<maxDist*maxDist){const f=0.0008;p.vx+=dx*f;p.vy+=dy*f;}}
          ctx.beginPath();ctx.arc(p.x,p.y,p.r,0,Math.PI*2);ctx.fillStyle='rgba(180,220,255,0.75)';ctx.fill();
          for(let j=i+1;j<particles.length;j++){const q=particles[j];const dx=p.x-q.x,dy=p.y-q.y;const dist=Math.hypot(dx,dy);
            if(dist<maxDist){const a=1-(dist/maxDist);ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(q.x,q.y);
              ctx.strokeStyle='rgba(80,180,170,'+(a*0.6)+')';ctx.lineWidth=1;ctx.stroke();}}}
        requestAnimationFrame(step);}
      window.addEventListener('resize',resize);
      window.addEventListener('mousemove',e=>{mouse.x=e.clientX;mouse.y=e.clientY;});
      window.addEventListener('mouseleave',()=>{mouse.x=mouse.y=null;});
      resize();step();
    })();
  </script>

  <!-- === CDR Analyzer Script (same as earlier) === -->
  <script>
   /* COLUMN_MAP (from your Python) */
const COLUMN_MAP = {
  "mobile": ["calling","a-number","from","target","calling party telephone number","target /a party number","target no","a party no","a party number"],
  "called": ["b party no","called","b-number","to","called party telephone number","lrn called no","b party number"],
  "imei": ["imei"],
  "imsi": ["imsi"],
  "datetime": ["datetime","date time","timestamp","call date","call time","call initiation time","start time","event time"],
  "cellid": ["cell","cell id","cid","lac","first cell id","last cell id","first cell global id","last cell global id","first cgi","last cgi","ecgi","cgi"],
  "duration": ["duration","dur(s)","seconds","call duration","dur"],
  "direction": ["call type","direction","type of connection","call forwarding","type"],
  "sms_center": ["sms centre number","sms center number","smsc no"],
  "roaming": ["roaming network/circle","roaming circle name","roam nw"],
  "msc_id": ["msc id","sw & msc id","switch id"],
  "ip_address": ["ip address","vowifi first ue ip","vowifi last ue ip"],
  "port": ["port no","port1","port2"]
};

let lastWorkbook = null;
let analysisResult = null;
let rawRows = null;
let headerRowIndex = null;
let headerRow = null;

const fileEl = document.getElementById('file');
const analyzeBtn = document.getElementById('analyzeBtn');
const downloadBtn = document.getElementById('downloadBtn');
const statusEl = document.getElementById('status');
const out = document.getElementById('output');

function setStatus(t){ statusEl.textContent = t; }

function trimLower(s){ return (s||"").toString().trim().toLowerCase(); }

/* Auto-detect header: read sheet into array of arrays, check first 25 rows to find decent header row */
function detectHeaderAndBuildRows(workbook) {
  // take first sheet
  const sheetName = workbook.SheetNames[0];
  const ws = workbook.Sheets[sheetName];
  const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" }); // array of arrays
  rawRows = rows; // global
  // look for header row among first 25 rows
  const maxSkip = Math.min(25, rows.length-1);
  for (let skip = 0; skip <= maxSkip; skip++){
    const candidate = rows[skip] || [];
    // Count non-empty candidate headers and count how many look like text
    let nonEmpty = candidate.filter(c => (c !== null && c.toString().trim()!=="")).length;
    // Heuristic: header row should have at least 2 non-empty cells and not be numeric-only row
    let numericCount = candidate.filter(c => !isNaN(Number(String(c).replace(/[^0-9.-]/g,"")))).length;
    if (nonEmpty >= 2 && numericCount < candidate.length) {
      headerRowIndex = skip;
      headerRow = candidate.map(c => c==null ? "" : String(c).trim());
      // Build array of objects using headerRow
      const data = [];
      for (let r = skip+1; r < rows.length; r++){
        const row = rows[r];
        if (!row) continue;
        const obj = {};
        for (let c=0;c<headerRow.length;c++){
          const key = headerRow[c] || ("col"+c);
          obj[key] = (row[c] === undefined ? "" : row[c]);
        }
        // skip entirely empty rows
        const anyVal = Object.values(obj).some(v => v !== null && String(v).trim() !== "");
        if (anyVal) data.push(obj);
      }
      return { headerRowIndex: skip, headerRow, data, rawArrays: rows };
    }
  }
  // fallback: use first row as header
  headerRowIndex = 0;
  headerRow = rows[0] ? rows[0].map(c => c==null?"":String(c).trim()) : [];
  const data = [];
  for (let r = 1; r < rows.length; r++){
    const row = rows[r]||[];
    const obj = {};
    for (let c=0;c<headerRow.length;c++){
      const key = headerRow[c] || ("col"+c);
      obj[key] = (row[c] === undefined ? "" : row[c]);
    }
    const anyVal = Object.values(obj).some(v => v !== null && String(v).trim() !== "");
    if (anyVal) data.push(obj);
  }
  return { headerRowIndex, headerRow, data, rawArrays: rows };
}

function mapColumnsFromHeaders(headers){
  const mapped = {};
  headers.forEach(h => {
    const col = String(h||"").trim();
    for (const key in COLUMN_MAP){
      if (mapped[key]) continue; // preserve first match
      for (const kw of COLUMN_MAP[key]){
        if (col.toLowerCase().includes(kw.toLowerCase())){
          mapped[key] = col;
          break;
        }
      }
    }
  });
  return mapped;
}

function parseDateTime(value){
  if (value == null) return null;
  const s = String(value).trim();
  if (!s) return null;
  // Try ISO / common parse
  const d = new Date(s);
  if (!isNaN(d.getTime())) return d;
  // Try numeric timestamp (seconds or ms)
  const num = Number(s.replace(/\D/g,""));
  if (!isNaN(num)){
    // if length ~13 treat as ms, if 10 treat as sec
    if (String(num).length >= 13) return new Date(num);
    if (String(num).length === 10) return new Date(num * 1000);
  }
  // fallback null
  return null;
}

function analyzeData(parsedObj){
  const headers = parsedObj.headerRow;
  const rows = parsedObj.data;
  const colMap = mapColumnsFromHeaders(headers);
  // Build normalized row objects: use normalized keys (mobile, called, imei, imsi, datetime, cellid, duration, direction)
  const normRows = rows.map(r => {
    const out = {};
    for (const k in COLUMN_MAP) {
      if (colMap[k]) out[k] = r[colMap[k]]; else out[k] = "";
    }
    // also preserve all original columns in Raw
    out.__orig = r;
    return out;
  });

  // ensure types
  normRows.forEach(r=>{
    r.duration = (r.duration===undefined || r.duration==null || r.duration==="" ) ? NaN : Number(String(r.duration).replace(/[^0-9.-]/g,"")) ;
    r.mobile = r.mobile==null ? "" : String(r.mobile).trim();
    r.called = r.called==null ? "" : String(r.called).trim();
    r.imei = r.imei==null ? "" : String(r.imei).trim();
    r.imsi = r.imsi==null ? "" : String(r.imsi).trim();
    r.cellid = r.cellid==null ? "" : String(r.cellid).trim();
    // datetime parsing
    r._dtobj = parseDateTime(r.datetime);
    r.Date = r._dtobj ? r._dtobj.toISOString().split("T")[0] : "";
    r.Time = r._dtobj ? r._dtobj.toTimeString().split(" ")[0] : "";
    r.Hour = (r._dtobj ? r._dtobj.getHours() : "");
  });

  // Call Count by mobile
  const callCountMap = {};
  normRows.forEach(r=>{
    const m = r.mobile || "(blank)";
    callCountMap[m] = (callCountMap[m] || 0) + 1;
  });
  const callCount = Object.entries(callCountMap).map(([k,v]) => ({ mobile: k, call_count: v }))
                          .sort((a,b)=>b.call_count - a.call_count);

  // Duration summary by mobile
  const durMap = {};
  normRows.forEach(r=>{
    const m = r.mobile || "(blank)";
    const val = isNaN(r.duration) ? 0 : r.duration;
    durMap[m] = (durMap[m] || 0) + val;
  });
  const durSum = Object.entries(durMap).map(([k,v]) => ({ mobile: k, duration: v }))
                        .sort((a,b)=>b.duration - a.duration);

  // IMEI / IMSI counts
  const counter = (arrField) => {
    const map = {};
    normRows.forEach(r=>{
      const key = (r[arrField] || "(blank)");
      map[key] = (map[key]||0)+1;
    });
    return Object.entries(map).map(([k,v])=>({ value:k, count:v })).sort((a,b)=>b.count - a.count);
  };
  const imei_cnt = counter("imei");
  const imsi_cnt = counter("imsi");
  const cellid_cnt = counter("cellid");

  // Hourly pattern
  const hourMap = {};
  normRows.forEach(r=>{
    const h = (r.Hour === "" ? "(blank)" : String(r.Hour));
    hourMap[h] = (hourMap[h]||0) + 1;
  });
  const hourly = Object.entries(hourMap).map(([k,v])=>({ Hour: k, Call_Count: v }))
                        .sort((a,b)=> {
                          // keep numeric hours in order, blanks last
                          if (a.Hour === "(blank)") return 1;
                          if (b.Hour === "(blank)") return -1;
                          return Number(a.Hour) - Number(b.Hour);
                        });

  // Summary metrics
  const totalRows = normRows.length;
  const uniqueMobile = new Set(normRows.map(r=>r.mobile)).size;
  const uniqueCalled = new Set(normRows.map(r=>r.called)).size;
  const uniqueIMEI = new Set(normRows.map(r=>r.imei)).size;
  const uniqueIMSI = new Set(normRows.map(r=>r.imsi)).size;
  const uniqueCell = new Set(normRows.map(r=>r.cellid)).size;

  // Date range
  const dates = normRows.map(r => r.Date).filter(d=>d).sort();
  const dateRange = dates.length ? (dates[0] + " → " + dates[dates.length-1]) : "N/A";

  const summary = [
    ["Total Rows", totalRows],
    ["Unique A Party (mobile)", uniqueMobile],
    ["Unique B Party (called)", uniqueCalled],
    ["Unique IMEI", uniqueIMEI],
    ["Unique IMSI", uniqueIMSI],
    ["Unique CellIDs", uniqueCell],
    ["Date Range", dateRange],
    ["Has Direction", (colMap["direction"]? "Yes":"No")],
    ["Has Duration", (colMap["duration"]? "Yes":"No")]
  ];

  return {
    normRows, callCount, durSum, imei_cnt, imsi_cnt, cellid_cnt, hourly, summary, parsedObj
  };
}

function renderResults(res){
  out.innerHTML = "";
  const wrap = document.createElement('div');

  // Summary metrics grid
  const sumDiv = document.createElement('div');
  sumDiv.className = 'summary-list';
  res.summary.forEach(([k,v])=>{
    const m = document.createElement('div'); m.className='metric';
    m.innerHTML = `<strong>${k}</strong><div class="small">${v}</div>`;
    sumDiv.appendChild(m);
  });
  wrap.appendChild(sumDiv);

  // small tables for top 10 of call count, duration, imei, imsi, cellid, hourly
  const mkTable = (title, arr, cols) => {
    const el = document.createElement('div');
    el.innerHTML = `<h3 style="margin-top:18px">${title}</h3>`;
    const tbl = document.createElement('table');
    const thead = document.createElement('tr');
    cols.forEach(c=> {
      const th = document.createElement('th'); th.textContent = c; thead.appendChild(th);
    });
    tbl.appendChild(thead);
    const max = Math.min(20, arr.length);
    for (let i=0;i<max;i++){
      const r = arr[i];
      const tr = document.createElement('tr');
      cols.forEach(c=>{
        const td = document.createElement('td');
        td.textContent = r[c]!==undefined ? r[c] : (r.value!==undefined && c.toLowerCase().includes('value') ? r.value : "");
        tr.appendChild(td);
      });
      tbl.appendChild(tr);
    }
    el.appendChild(tbl);
    return el;
  };

  wrap.appendChild(mkTable("Top Call Count (per mobile)", res.callCount.map(x=>({ mobile:x.mobile, call_count:x.call_count })), ["mobile","call_count"]));
  wrap.appendChild(mkTable("Top Duration (per mobile)", res.durSum.map(x=>({ mobile:x.mobile, duration:x.duration })), ["mobile","duration"]));
  wrap.appendChild(mkTable("Top IMEI", res.imei_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"]));
  wrap.appendChild(mkTable("Top IMSI", res.imsi_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"]));
  wrap.appendChild(mkTable("Top CellID", res.cellid_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"]));
  wrap.appendChild(mkTable("Hourly Pattern", res.hourly, ["Hour","Call_Count"]));

  // show first 200 raw rows as preview
  const rawPreview = res.parsedObj.rawArrays;
  const pre = document.createElement('div');
  pre.innerHTML = `<h3 style="margin-top:18px">Raw Preview (first 200 rows)</h3>`;
  const tb = document.createElement('table');
  const head = document.createElement('tr');
  const hdrs = res.parsedObj.headerRow.map(h=>h||"(blank)");
  hdrs.forEach(h=>{ const th=document.createElement('th'); th.textContent = h; head.appendChild(th); });
  tb.appendChild(head);
  const limit = Math.min(200, rawPreview.length - (res.parsedObj.headerRowIndex+1));
  for (let i = 0; i < limit; i++){
    const r = rawPreview[res.parsedObj.headerRowIndex + 1 + i] || [];
    const tr = document.createElement('tr');
    for (let c=0;c<hdrs.length;c++){
      const td = document.createElement('td'); td.textContent = (r[c] === undefined ? "" : r[c]); tr.appendChild(td);
    }
    tb.appendChild(tr);
  }
  pre.appendChild(tb);
  wrap.appendChild(pre);

  out.appendChild(wrap);
}

function buildWorkbookAndEnableDownload(res){
  // Create workbook with multiple sheets
  const wb = XLSX.utils.book_new();

  // Summary sheet: convert summary arr to sheet
  const summarySheet = XLSX.utils.aoa_to_sheet(res.summary);
  XLSX.utils.book_append_sheet(wb, summarySheet, "Summary");

  const toSheet = (arr, cols, name) => {
    const aoa = [cols];
    arr.forEach(r=> {
      const row = cols.map(c => r[c] !== undefined ? r[c] : (r.value!==undefined && c.toLowerCase().includes('value') ? r.value : ""));
      aoa.push(row);
    });
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    XLSX.utils.book_append_sheet(wb, ws, name);
  };

  toSheet(res.callCount.map(x=>({ mobile:x.mobile, call_count:x.call_count })), ["mobile","call_count"], "Call Count");
  toSheet(res.durSum.map(x=>({ mobile:x.mobile, duration:x.duration })), ["mobile","duration"], "Duration Summary");
  toSheet(res.imei_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"], "Max IMEI");
  toSheet(res.imsi_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"], "Max IMSI");
  toSheet(res.cellid_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"], "Max CellID");
  toSheet(res.hourly, ["Hour","Call_Count"], "Hourly Pattern");

  // Raw Data: rebuild from parsedObj
  const headers = res.parsedObj.headerRow;
  const rawAoA = [headers];
  // append all data rows (careful for huge files)
  const maxRowsToExport = Math.min(50000, res.parsedObj.rawArrays.length - (res.parsedObj.headerRowIndex+1)); // safety cap
  for (let r = res.parsedObj.headerRowIndex + 1; r < res.parsedObj.rawArrays.length && rawAoA.length <= maxRowsToExport; r++){
    const row = res.parsedObj.rawArrays[r] || [];
    // ensure same width
    const outRow = headers.map((h,i)=> row[i] === undefined ? "" : row[i]);
    rawAoA.push(outRow);
  }
  const rawWs = XLSX.utils.aoa_to_sheet(rawAoA);
  XLSX.utils.book_append_sheet(wb, rawWs, "Raw Data");

  // Store workbook globally so user can download
  lastWorkbook = wb;
  downloadBtn.disabled = false;
}

analyzeBtn.addEventListener('click', async ()=>{
  const f = fileEl.files[0];
  if (!f) { alert("Please choose a file first."); return; }
  setStatus("Reading file...");
  const data = await f.arrayBuffer();
  let workbook;
  try {
    workbook = XLSX.read(data, { type: "array", cellDates:true, cellNF:false, cellText:true });
  } catch (e){
    alert("Failed to parse file: " + e);
    setStatus("Failed to parse file.");
    return;
  }
  setStatus("Detecting header...");
  const parsed = detectHeaderAndBuildRows(workbook);
  setStatus("Mapping columns & analyzing...");
  const res = analyzeData(parsed);
  analysisResult = res;
  renderResults(res);
  buildWorkbookAndEnableDownload(res);
  setStatus("Analysis complete. You can download the Excel report.");
});

downloadBtn.addEventListener('click', ()=>{
  if (!lastWorkbook) return;
  const fname = "CDR_Analysis_Report.xlsx";
  XLSX.writeFile(lastWorkbook, fname);
});

fileEl.addEventListener('change', () => {
  downloadBtn.disabled = true;
  lastWorkbook = null;
  analysisResult = null;
  setStatus(fileEl.files[0] ? ("Selected: " + fileEl.files[0].name) : "No file selected.");
  out.innerHTML = "";
});
</script>
</body>
</html>
  
