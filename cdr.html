<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ProbeMind — CDR Analysis (Client-side)</title>
<style>
  body { font-family: system-ui, Roboto, Arial; background: #0b0f16; color: #eaeaea; margin: 0; padding: 28px; }
  .card { background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.05); padding:18px; border-radius:10px; max-width:1100px; margin:0 auto; }
  h1 { margin: 0 0 12px 0; }
  input[type=file] { display:block; margin-bottom:12px; }
  button { background:#14b8a6; color:#021012; border:none; padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:700; }
  .row { display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
  table { border-collapse:collapse; width:100%; margin:10px 0 22px; background: rgba(0,0,0,0.25); }
  th,td { padding:8px 10px; border:1px solid rgba(255,255,255,0.04); text-align:left; font-size:13px; color:#eaeaea; }
  .small { font-size:13px; color:#9db0c6; }
  pre { background: rgba(255,255,255,0.02); padding:12px; border-radius:8px; overflow:auto; }
  .flex { display:flex; gap:12px; flex-wrap:wrap; }
  .summary-list { display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); gap:8px; }
  .metric { background: rgba(255,255,255,0.02); padding:10px; border-radius:8px; }
</style>
</head>
<body>
  <div class="card">
    <h1>ProbeMind — CDR Analysis (Client-side)</h1>
    <div class="small">Upload .csv / .xlsx / .xls / .xlsb file. Page will auto-detect header row (first 25 rows) and produce an analysis workbook you can download.</div>

    <div style="height:12px"></div>
    <input id="file" type="file" accept=".csv,.xlsx,.xls,.xlsb"/>
    <div class="row">
      <button id="analyzeBtn">Analyze CDR</button>
      <button id="downloadBtn" disabled>Download Excel Report</button>
      <div id="status" class="small">No file selected.</div>
    </div>

    <div id="output"></div>
  </div>

  <!-- SheetJS (xlsx) CDN -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>
/* COLUMN_MAP (from your Python) */
const COLUMN_MAP = {
  "mobile": ["calling","a-number","from","target","calling party telephone number","target /a party number","target no","a party no","a party number"],
  "called": ["b party no","called","b-number","to","called party telephone number","lrn called no","b party number"],
  "imei": ["imei"],
  "imsi": ["imsi"],
  "datetime": ["datetime","date time","timestamp","call date","call time","call initiation time","start time","event time"],
  "cellid": ["cell","cell id","cid","lac","first cell id","last cell id","first cell global id","last cell global id","first cgi","last cgi","ecgi","cgi"],
  "duration": ["duration","dur(s)","seconds","call duration","dur"],
  "direction": ["call type","direction","type of connection","call forwarding","type"],
  "sms_center": ["sms centre number","sms center number","smsc no"],
  "roaming": ["roaming network/circle","roaming circle name","roam nw"],
  "msc_id": ["msc id","sw & msc id","switch id"],
  "ip_address": ["ip address","vowifi first ue ip","vowifi last ue ip"],
  "port": ["port no","port1","port2"]
};

let lastWorkbook = null;
let analysisResult = null;
let rawRows = null;
let headerRowIndex = null;
let headerRow = null;

const fileEl = document.getElementById('file');
const analyzeBtn = document.getElementById('analyzeBtn');
const downloadBtn = document.getElementById('downloadBtn');
const statusEl = document.getElementById('status');
const out = document.getElementById('output');

function setStatus(t){ statusEl.textContent = t; }

function trimLower(s){ return (s||"").toString().trim().toLowerCase(); }

/* Auto-detect header: read sheet into array of arrays, check first 25 rows to find decent header row */
function detectHeaderAndBuildRows(workbook) {
  // take first sheet
  const sheetName = workbook.SheetNames[0];
  const ws = workbook.Sheets[sheetName];
  const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" }); // array of arrays
  rawRows = rows; // global
  // look for header row among first 25 rows
  const maxSkip = Math.min(25, rows.length-1);
  for (let skip = 0; skip <= maxSkip; skip++){
    const candidate = rows[skip] || [];
    // Count non-empty candidate headers and count how many look like text
    let nonEmpty = candidate.filter(c => (c !== null && c.toString().trim()!=="")).length;
    // Heuristic: header row should have at least 2 non-empty cells and not be numeric-only row
    let numericCount = candidate.filter(c => !isNaN(Number(String(c).replace(/[^0-9.-]/g,"")))).length;
    if (nonEmpty >= 2 && numericCount < candidate.length) {
      headerRowIndex = skip;
      headerRow = candidate.map(c => c==null ? "" : String(c).trim());
      // Build array of objects using headerRow
      const data = [];
      for (let r = skip+1; r < rows.length; r++){
        const row = rows[r];
        if (!row) continue;
        const obj = {};
        for (let c=0;c<headerRow.length;c++){
          const key = headerRow[c] || ("col"+c);
          obj[key] = (row[c] === undefined ? "" : row[c]);
        }
        // skip entirely empty rows
        const anyVal = Object.values(obj).some(v => v !== null && String(v).trim() !== "");
        if (anyVal) data.push(obj);
      }
      return { headerRowIndex: skip, headerRow, data, rawArrays: rows };
    }
  }
  // fallback: use first row as header
  headerRowIndex = 0;
  headerRow = rows[0] ? rows[0].map(c => c==null?"":String(c).trim()) : [];
  const data = [];
  for (let r = 1; r < rows.length; r++){
    const row = rows[r]||[];
    const obj = {};
    for (let c=0;c<headerRow.length;c++){
      const key = headerRow[c] || ("col"+c);
      obj[key] = (row[c] === undefined ? "" : row[c]);
    }
    const anyVal = Object.values(obj).some(v => v !== null && String(v).trim() !== "");
    if (anyVal) data.push(obj);
  }
  return { headerRowIndex, headerRow, data, rawArrays: rows };
}

function mapColumnsFromHeaders(headers){
  const mapped = {};
  headers.forEach(h => {
    const col = String(h||"").trim();
    for (const key in COLUMN_MAP){
      if (mapped[key]) continue; // preserve first match
      for (const kw of COLUMN_MAP[key]){
        if (col.toLowerCase().includes(kw.toLowerCase())){
          mapped[key] = col;
          break;
        }
      }
    }
  });
  return mapped;
}

function parseDateTime(value){
  if (value == null) return null;
  const s = String(value).trim();
  if (!s) return null;
  // Try ISO / common parse
  const d = new Date(s);
  if (!isNaN(d.getTime())) return d;
  // Try numeric timestamp (seconds or ms)
  const num = Number(s.replace(/\D/g,""));
  if (!isNaN(num)){
    // if length ~13 treat as ms, if 10 treat as sec
    if (String(num).length >= 13) return new Date(num);
    if (String(num).length === 10) return new Date(num * 1000);
  }
  // fallback null
  return null;
}

function analyzeData(parsedObj){
  const headers = parsedObj.headerRow;
  const rows = parsedObj.data;
  const colMap = mapColumnsFromHeaders(headers);
  // Build normalized row objects: use normalized keys (mobile, called, imei, imsi, datetime, cellid, duration, direction)
  const normRows = rows.map(r => {
    const out = {};
    for (const k in COLUMN_MAP) {
      if (colMap[k]) out[k] = r[colMap[k]]; else out[k] = "";
    }
    // also preserve all original columns in Raw
    out.__orig = r;
    return out;
  });

  // ensure types
  normRows.forEach(r=>{
    r.duration = (r.duration===undefined || r.duration==null || r.duration==="" ) ? NaN : Number(String(r.duration).replace(/[^0-9.-]/g,"")) ;
    r.mobile = r.mobile==null ? "" : String(r.mobile).trim();
    r.called = r.called==null ? "" : String(r.called).trim();
    r.imei = r.imei==null ? "" : String(r.imei).trim();
    r.imsi = r.imsi==null ? "" : String(r.imsi).trim();
    r.cellid = r.cellid==null ? "" : String(r.cellid).trim();
    // datetime parsing
    r._dtobj = parseDateTime(r.datetime);
    r.Date = r._dtobj ? r._dtobj.toISOString().split("T")[0] : "";
    r.Time = r._dtobj ? r._dtobj.toTimeString().split(" ")[0] : "";
    r.Hour = (r._dtobj ? r._dtobj.getHours() : "");
  });

  // Call Count by mobile
  const callCountMap = {};
  normRows.forEach(r=>{
    const m = r.mobile || "(blank)";
    callCountMap[m] = (callCountMap[m] || 0) + 1;
  });
  const callCount = Object.entries(callCountMap).map(([k,v]) => ({ mobile: k, call_count: v }))
                          .sort((a,b)=>b.call_count - a.call_count);

  // Duration summary by mobile
  const durMap = {};
  normRows.forEach(r=>{
    const m = r.mobile || "(blank)";
    const val = isNaN(r.duration) ? 0 : r.duration;
    durMap[m] = (durMap[m] || 0) + val;
  });
  const durSum = Object.entries(durMap).map(([k,v]) => ({ mobile: k, duration: v }))
                        .sort((a,b)=>b.duration - a.duration);

  // IMEI / IMSI counts
  const counter = (arrField) => {
    const map = {};
    normRows.forEach(r=>{
      const key = (r[arrField] || "(blank)");
      map[key] = (map[key]||0)+1;
    });
    return Object.entries(map).map(([k,v])=>({ value:k, count:v })).sort((a,b)=>b.count - a.count);
  };
  const imei_cnt = counter("imei");
  const imsi_cnt = counter("imsi");
  const cellid_cnt = counter("cellid");

  // Hourly pattern
  const hourMap = {};
  normRows.forEach(r=>{
    const h = (r.Hour === "" ? "(blank)" : String(r.Hour));
    hourMap[h] = (hourMap[h]||0) + 1;
  });
  const hourly = Object.entries(hourMap).map(([k,v])=>({ Hour: k, Call_Count: v }))
                        .sort((a,b)=> {
                          // keep numeric hours in order, blanks last
                          if (a.Hour === "(blank)") return 1;
                          if (b.Hour === "(blank)") return -1;
                          return Number(a.Hour) - Number(b.Hour);
                        });

  // Summary metrics
  const totalRows = normRows.length;
  const uniqueMobile = new Set(normRows.map(r=>r.mobile)).size;
  const uniqueCalled = new Set(normRows.map(r=>r.called)).size;
  const uniqueIMEI = new Set(normRows.map(r=>r.imei)).size;
  const uniqueIMSI = new Set(normRows.map(r=>r.imsi)).size;
  const uniqueCell = new Set(normRows.map(r=>r.cellid)).size;

  // Date range
  const dates = normRows.map(r => r.Date).filter(d=>d).sort();
  const dateRange = dates.length ? (dates[0] + " → " + dates[dates.length-1]) : "N/A";

  const summary = [
    ["Total Rows", totalRows],
    ["Unique A Party (mobile)", uniqueMobile],
    ["Unique B Party (called)", uniqueCalled],
    ["Unique IMEI", uniqueIMEI],
    ["Unique IMSI", uniqueIMSI],
    ["Unique CellIDs", uniqueCell],
    ["Date Range", dateRange],
    ["Has Direction", (colMap["direction"]? "Yes":"No")],
    ["Has Duration", (colMap["duration"]? "Yes":"No")]
  ];

  return {
    normRows, callCount, durSum, imei_cnt, imsi_cnt, cellid_cnt, hourly, summary, parsedObj
  };
}

function renderResults(res){
  out.innerHTML = "";
  const wrap = document.createElement('div');

  // Summary metrics grid
  const sumDiv = document.createElement('div');
  sumDiv.className = 'summary-list';
  res.summary.forEach(([k,v])=>{
    const m = document.createElement('div'); m.className='metric';
    m.innerHTML = `<strong>${k}</strong><div class="small">${v}</div>`;
    sumDiv.appendChild(m);
  });
  wrap.appendChild(sumDiv);

  // small tables for top 10 of call count, duration, imei, imsi, cellid, hourly
  const mkTable = (title, arr, cols) => {
    const el = document.createElement('div');
    el.innerHTML = `<h3 style="margin-top:18px">${title}</h3>`;
    const tbl = document.createElement('table');
    const thead = document.createElement('tr');
    cols.forEach(c=> {
      const th = document.createElement('th'); th.textContent = c; thead.appendChild(th);
    });
    tbl.appendChild(thead);
    const max = Math.min(20, arr.length);
    for (let i=0;i<max;i++){
      const r = arr[i];
      const tr = document.createElement('tr');
      cols.forEach(c=>{
        const td = document.createElement('td');
        td.textContent = r[c]!==undefined ? r[c] : (r.value!==undefined && c.toLowerCase().includes('value') ? r.value : "");
        tr.appendChild(td);
      });
      tbl.appendChild(tr);
    }
    el.appendChild(tbl);
    return el;
  };

  wrap.appendChild(mkTable("Top Call Count (per mobile)", res.callCount.map(x=>({ mobile:x.mobile, call_count:x.call_count })), ["mobile","call_count"]));
  wrap.appendChild(mkTable("Top Duration (per mobile)", res.durSum.map(x=>({ mobile:x.mobile, duration:x.duration })), ["mobile","duration"]));
  wrap.appendChild(mkTable("Top IMEI", res.imei_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"]));
  wrap.appendChild(mkTable("Top IMSI", res.imsi_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"]));
  wrap.appendChild(mkTable("Top CellID", res.cellid_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"]));
  wrap.appendChild(mkTable("Hourly Pattern", res.hourly, ["Hour","Call_Count"]));

  // show first 200 raw rows as preview
  const rawPreview = res.parsedObj.rawArrays;
  const pre = document.createElement('div');
  pre.innerHTML = `<h3 style="margin-top:18px">Raw Preview (first 200 rows)</h3>`;
  const tb = document.createElement('table');
  const head = document.createElement('tr');
  const hdrs = res.parsedObj.headerRow.map(h=>h||"(blank)");
  hdrs.forEach(h=>{ const th=document.createElement('th'); th.textContent = h; head.appendChild(th); });
  tb.appendChild(head);
  const limit = Math.min(200, rawPreview.length - (res.parsedObj.headerRowIndex+1));
  for (let i = 0; i < limit; i++){
    const r = rawPreview[res.parsedObj.headerRowIndex + 1 + i] || [];
    const tr = document.createElement('tr');
    for (let c=0;c<hdrs.length;c++){
      const td = document.createElement('td'); td.textContent = (r[c] === undefined ? "" : r[c]); tr.appendChild(td);
    }
    tb.appendChild(tr);
  }
  pre.appendChild(tb);
  wrap.appendChild(pre);

  out.appendChild(wrap);
}

function buildWorkbookAndEnableDownload(res){
  // Create workbook with multiple sheets
  const wb = XLSX.utils.book_new();

  // Summary sheet: convert summary arr to sheet
  const summarySheet = XLSX.utils.aoa_to_sheet(res.summary);
  XLSX.utils.book_append_sheet(wb, summarySheet, "Summary");

  const toSheet = (arr, cols, name) => {
    const aoa = [cols];
    arr.forEach(r=> {
      const row = cols.map(c => r[c] !== undefined ? r[c] : (r.value!==undefined && c.toLowerCase().includes('value') ? r.value : ""));
      aoa.push(row);
    });
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    XLSX.utils.book_append_sheet(wb, ws, name);
  };

  toSheet(res.callCount.map(x=>({ mobile:x.mobile, call_count:x.call_count })), ["mobile","call_count"], "Call Count");
  toSheet(res.durSum.map(x=>({ mobile:x.mobile, duration:x.duration })), ["mobile","duration"], "Duration Summary");
  toSheet(res.imei_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"], "Max IMEI");
  toSheet(res.imsi_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"], "Max IMSI");
  toSheet(res.cellid_cnt.map(x=>({ value:x.value, count:x.count })), ["value","count"], "Max CellID");
  toSheet(res.hourly, ["Hour","Call_Count"], "Hourly Pattern");

  // Raw Data: rebuild from parsedObj
  const headers = res.parsedObj.headerRow;
  const rawAoA = [headers];
  // append all data rows (careful for huge files)
  const maxRowsToExport = Math.min(50000, res.parsedObj.rawArrays.length - (res.parsedObj.headerRowIndex+1)); // safety cap
  for (let r = res.parsedObj.headerRowIndex + 1; r < res.parsedObj.rawArrays.length && rawAoA.length <= maxRowsToExport; r++){
    const row = res.parsedObj.rawArrays[r] || [];
    // ensure same width
    const outRow = headers.map((h,i)=> row[i] === undefined ? "" : row[i]);
    rawAoA.push(outRow);
  }
  const rawWs = XLSX.utils.aoa_to_sheet(rawAoA);
  XLSX.utils.book_append_sheet(wb, rawWs, "Raw Data");

  // Store workbook globally so user can download
  lastWorkbook = wb;
  downloadBtn.disabled = false;
}

analyzeBtn.addEventListener('click', async ()=>{
  const f = fileEl.files[0];
  if (!f) { alert("Please choose a file first."); return; }
  setStatus("Reading file...");
  const data = await f.arrayBuffer();
  let workbook;
  try {
    workbook = XLSX.read(data, { type: "array", cellDates:true, cellNF:false, cellText:true });
  } catch (e){
    alert("Failed to parse file: " + e);
    setStatus("Failed to parse file.");
    return;
  }
  setStatus("Detecting header...");
  const parsed = detectHeaderAndBuildRows(workbook);
  setStatus("Mapping columns & analyzing...");
  const res = analyzeData(parsed);
  analysisResult = res;
  renderResults(res);
  buildWorkbookAndEnableDownload(res);
  setStatus("Analysis complete. You can download the Excel report.");
});

downloadBtn.addEventListener('click', ()=>{
  if (!lastWorkbook) return;
  const fname = "CDR_Analysis_Report.xlsx";
  XLSX.writeFile(lastWorkbook, fname);
});

fileEl.addEventListener('change', () => {
  downloadBtn.disabled = true;
  lastWorkbook = null;
  analysisResult = null;
  setStatus(fileEl.files[0] ? ("Selected: " + fileEl.files[0].name) : "No file selected.");
  out.innerHTML = "";
});
</script>
</body>
</html>
